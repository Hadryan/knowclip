import * as r from '../redux'
import { toTimestamp } from '../utils/ffmpeg'
import { extname, basename } from 'path'
import { unparse } from 'papaparse'
import { getNoteTypeFields } from '../utils/noteType'
import { getPreviouslyLoadedFile } from '../selectors'
const SAFE_SEPARATOR = '-'
const SAFE_MILLISECONDS_SEPARATOR = '_'

const roughEscape = (text: string) => text.replace(/\n/g, '<br />')

const FRONT_SIDE = '{{FrontSide}}'
const HR = '<hr id="answer" />'
const TRANSCRIPTION = '<p class="transcription">{{transcription}}</p>'
const MEANING = '<p class="meaning">{{meaning}}</p>'
const PRONUNCIATION = `{{#pronunciation}}
<p class="pronunciation">{{pronunciation}}
</p>
{{/pronunciation}}`
const NOTES = `{{#notes}}
<p class="notes">{{notes}}
</p>
{{/notes}}`

const getCards = (noteType: NoteType) => [
  {
    name: 'Listening',
    questionFormat: `â™«{{sound}}`,
    answerFormat: [
      FRONT_SIDE,
      HR,
      TRANSCRIPTION,
      PRONUNCIATION,
      MEANING,
      NOTES,
    ].join('\n\n'),
  },
  {
    name: 'Reading',
    questionFormat: TRANSCRIPTION,
    answerFormat: [
      FRONT_SIDE,
      HR,
      '{{sound}}',
      PRONUNCIATION,
      MEANING,
      NOTES,
    ].join('\n\n'),
  },
]

export const getApkgExportData = (
  state: AppState,
  project: ProjectFileRecord,
  clipIds: Array<ClipId>
): ApkgExportData => {
  const fieldNames = getNoteTypeFields(project.noteType)
  const mediaFiles = r.getProjectMediaFileRecords(state, project.id)

  // sort and validate
  clipIds.sort((id, id2) => {
    const clip = r.getClip(state, id)
    if (!clip) throw new Error('Could not find clip ' + id)

    const clip2 = r.getClip(state, id2)
    if (!clip2) throw new Error('Could not find clip ' + id2)

    const fileRecord = mediaFiles.find(media => media.id === clip.fileId)
    if (!fileRecord)
      throw new Error(`Couldn't find media metadata for clip ${id}`)
    const fileLoaded = getPreviouslyLoadedFile(state, fileRecord)
    if (!(fileLoaded && fileLoaded.status === 'CURRENTLY_LOADED'))
      throw new Error(`Please open ${fileRecord.name} and try again.`)

    const fileRecord2 = mediaFiles.find(media => media.id === clip.fileId)
    if (!fileRecord2)
      throw new Error(`Couldn't find media metadata for clip ${id}`)

    const fileIndex1 = mediaFiles.indexOf(fileRecord)
    const fileIndex2 = mediaFiles.findIndex(media => media.id === clip2.fileId)

    if (fileIndex1 < fileIndex2) return -1
    if (fileIndex1 > fileIndex2) return 1

    if (clip.start < clip2.start) return -1
    if (clip.start > clip2.start) return 1
    return 0
  })

  const clips = clipIds.map((id, i) => {
    const clip = r.getClip(state, id)
    if (!clip) throw new Error('Could not find clip ' + id)

    const metadataAndPath = mediaFiles.find(media => media.id === clip.fileId)
    if (!metadataAndPath)
      throw new Error(`Couldn't find media metadata for clip ${id}`)
    const fileRecord = mediaFiles.find(media => media.id === clip.fileId)
    if (!fileRecord)
      throw new Error(`Couldn't find media metadata for clip ${id}`)
    const fileLoaded = getPreviouslyLoadedFile(state, fileRecord)
    if (!(fileLoaded && fileLoaded.status === 'CURRENTLY_LOADED'))
      throw new Error(`Please open ${fileRecord.name} and try again.`)
    const extension = extname(fileLoaded.filePath)
    const filenameWithoutExtension = basename(fileLoaded.filePath, extension)

    const startTime = r.getMillisecondsAtX(state, clip.start)
    const endTime = r.getMillisecondsAtX(state, clip.end)
    const outputFilename = `${filenameWithoutExtension
      .replace(/\[/g, '__br__')
      .replace(/\]/g, '__rb__')}___${toTimestamp(
      startTime,
      SAFE_SEPARATOR
    )}-${toTimestamp(
      endTime,
      SAFE_SEPARATOR,
      SAFE_MILLISECONDS_SEPARATOR
    )}___afcaId${id}${'.mp3'}`

    const fieldValues = Object.values(clip.flashcard.fields).map(roughEscape)

    return {
      sourceFilePath: fileLoaded.filePath,
      startTime,
      endTime,
      outputFilename,
      flashcardSpecs: {
        sortField: 'transcription',
        fields: [clip.id, ...fieldValues, `[sound:${outputFilename}]`],
        tags: clip.flashcard.tags || [],
        due: i,
      },
    }
  })

  return {
    deckName: `${project.name} (Generated by AFCA)`,
    template: {
      fields: ['id', ...fieldNames, 'sound'],
      cards: getCards(project.noteType),
      css: `.card {
  font-family: Helvetica, Arial;
  font-size: 16px;
  text-align: center;
  color: black;
  background-color: white;
  line-height: 1.25
}

.transcription {
  font-size: 2em;
}

.pronunciation {
  font-style: italic;
  font-size: 1.4em;
}

.meaning {
  margin-top: 4em;
  margin-bottom: 4em;
}

.notes {
  background-color: #efefef;
  padding: .8em;
  border-radius: .2em;
  text-align: justify;
  max-width: 40em;
  margin-left: auto;
  margin-right: auto;
}`,
    },
    clips,
  }
}

export const getCsvText = (exportData: ApkgExportData) => {
  const csvData = exportData.clips.map(({ flashcardSpecs }) =>
    [...flashcardSpecs.fields].concat(flashcardSpecs.tags.join(' '))
  )

  return unparse(csvData)
}

// web
// const exportCsv = (files, flashcards) => {
//   const usableFlashcards = files
//     .map(file => flashcards[file.name])
//     .filter(({ de, en }) => de.trim() || en.trim())
//     .map(({ en, de }, i) => [de, en, `[sound:${files[i].name}]`])
//   // TODO: alert if no usable
//   let csv = unparse(usableFlashcards)
//   const filename = 'export.csv'
//
//   if (!csv.match(/^data:text\/csv/i)) {
//     csv = 'data:text/csv;charset=utf-8,' + csv
//   }
//   const data = encodeURI(csv)
//
//   const link = document.createElement('a')
//   link.setAttribute('href', data)
//   link.setAttribute('download', filename)
//   link.click()
// }
